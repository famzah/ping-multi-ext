#!/usr/bin/env python3

from blessings import Terminal
import time
import threading
import sys
import curtsies
import signal

gvars = {}

class TermCtrl:
    def __init__(self, key):
        self.code = getattr(gvars['term'], key)

def _compose_printed_str(data_row, t_width):
    printed_str = ''
    pstr_len = 0

    for part_idx, part_value in enumerate(data_row):
        if isinstance(part_value, TermCtrl):
            printed_str += part_value.code
        elif isinstance(part_value, str):
            if pstr_len + len(part_value) <= t_width:
                printed_str += part_value
                pstr_len += len(part_value)
            else: # we are going to exceed the width
                cut_value = part_value[0:(t_width - pstr_len)]

                printed_str += cut_value
                pstr_len += len(cut_value)

                break # stop processing the input data
        else:
            raise NotImplementedError(part_value)

    if pstr_len > t_width:
        raise Exception(f'Assertion failed: "{printed_str}"')

    return printed_str

def _sanity_check_data_row(data_row, i):
    for part_idx, part_value in enumerate(data_row):
        part_str_id = f'Screen data row with index {i} part {part_idx}'

        if not isinstance(part_value, str) and not isinstance(part_value, TermCtrl):
            raise ValueError(f'{part_str_id} is not "str" nor "TermCtrl"')
        if isinstance(part_value, str):
            for c in ['\n', '\r', '\t']:
                if c in part_value:
                    raise ValueError(
                        f'{part_str_id} cannot contain the ASCII character {ord(c)}: "{part_value}"'
                    )

def ui_print(term, data):
    # get it every time, so that we react if the terminal changes (ie. if it gets resized)
    t_height = term.height
    t_width = term.width

    term_size_changed = False
    if 'ui_old_size' not in gvars \
      or t_height != gvars['ui_old_size']['height'] or t_width != gvars['ui_old_size']['width']:
        #
        term_size_changed = True
        gvars['ui_old_size'] = {
            'height': t_height,
            'width': t_width,
        }

    if term_size_changed:
        print(term.clear(), end='', flush=True)
        if 'ui_old_screen' in gvars:
            del gvars['ui_old_screen']

    if 'ui_old_screen' not in gvars:
        gvars['ui_old_screen'] = {}
    old_screen = gvars['ui_old_screen']

    screen_changed = False
    for i in range(0, t_height):
        if i not in old_screen: # first initialization of "old_screen"
            old_screen[i] = None

        try:
            data_row = data[i]
        except IndexError:
            data_row = ['']

        _sanity_check_data_row(data_row, i)

        printed_str = _compose_printed_str(data_row, t_width)

        if printed_str != old_screen[i]: # this could be optimized to draw only a part of the line
            old_screen[i] = printed_str
            screen_changed = True
            # always restore the color to "normal" in case we cut this in the data row
            print(term.move(i, 0) + printed_str + term.normal, end='', flush=False)

    if screen_changed:
        sys.stdout.flush()

    return term_size_changed, t_height, t_width

def ui_renderer(all_hosts):
    term = gvars['term']

    if term.number_of_colors < 8:
        raise Exception('Your terminal does not support colors')

    with gvars['exit_fullscreen_lock']:
        gvars['exited_fullscreen'] = False
        print(term.enter_fullscreen())

    pdata = []
    with term.hidden_cursor():
        while not gvars['stop_run']:
            term_size_changed, t_height, t_width = ui_print(term, pdata)

            if not term_size_changed:
                time.sleep(0.05)

            pdata = []

            pdata.append([TermCtrl('green'), 'Menu...', '1234567890' * 15 + 'Z', TermCtrl('red'), 'abb'])
            pdata.append([''])

            if term_size_changed:
                min_idx = 0
                max_idx = t_height - len(pdata) # skip the header rows
                sel_idx = None

            if max_idx < 0:
                continue # terminal is so small that it doesn't have any space for data

            max_host_len = 16
            for host in list(all_hosts.keys())[min_idx:max_idx]:
                pdata.append(['{:<16s}'.format(host[0:max_host_len])])

    # only this thread and Exceptions print any info
    # therefore, it's this thread's task to exit full screen
    exit_fullscreen()

def _exit_fullscreen():
    if not gvars['exited_fullscreen']:
        gvars['exited_fullscreen'] = True
        print(gvars['term'].exit_fullscreen(), end='', flush=True)

def exit_fullscreen():
    if threading.current_thread() != gvars['ui_renderer_thread']: # avoid deadlock
        with gvars['exit_fullscreen_lock']:
            _exit_fullscreen()
    else: # ui_renderer_thread (the only thread which can set "exited_fullscreen = False"
        _exit_fullscreen()

def thread_runner(*args):
    try:
        func = args[0]
        func(*args[1:])
    except:
        gvars['stop_run'] = True

        if threading.current_thread() != gvars['ui_renderer_thread']:
            # this thread must exit very soon, because of the gvars['stop_run'] == False
            # wait for it to call exit_fullscreen(), so that we can successfully
            # print() the exception info
            gvars['ui_renderer_thread'].join(5) # best effort

        exit_fullscreen()
        raise # and print() the exception info

def stdin_processor():
    with curtsies.Input() as input_generator:
        while not gvars['stop_run']:
            e = input_generator.send(0.05)
            if e is None:
                continue # nothing pressed within the timeout period

def sigint_handler(a, b):
    gvars['stop_run'] = True

def get_hosts():
    ret = {}
    for i in range(1, 51):
        ret['host-{} {}'.format(i, str(i)*i)] = {}
    return ret

def main():
    gvars['term'] = Terminal()

    gvars['stop_run'] = False

    gvars['exited_fullscreen'] = True # by default we're not in this mode
    gvars['exit_fullscreen_lock'] = threading.Lock()

    gvars['ui_renderer_thread'] = threading.Thread(target=thread_runner, args=(
        ui_renderer, get_hosts()
    ))

    thr_list = [
        gvars['ui_renderer_thread'],
        threading.Thread(target=thread_runner, args=(stdin_processor,)),
    ]

    signal.signal(signal.SIGINT, sigint_handler) # CTRL+C

    for thr in thr_list:
        thr.start()

    while not gvars['stop_run']:
        time.sleep(0.05)

    while threading.active_count() > 1:
        for thr in thr_list:
            if thr.is_alive():
                thr.join()
        time.sleep(0.05)

thread_runner(main)
