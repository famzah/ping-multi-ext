#!/usr/bin/env python3

from blessings import Terminal
import time
import threading
import sys
import curtsies
import signal
import random

gvars = {}

class TermCtrl:
    def __init__(self, key):
        self.code = getattr(gvars['term'], key)

def _compose_printed_str(data_row, t_width):
    printed_str = ''
    pstr_len = 0

    for part_idx, part_value in enumerate(data_row):
        if isinstance(part_value, TermCtrl):
            printed_str += part_value.code
        elif isinstance(part_value, str):
            if pstr_len + len(part_value) <= t_width:
                printed_str += part_value
                pstr_len += len(part_value)
            else: # we are going to exceed the width
                cut_value = part_value[0:(t_width - pstr_len)]

                printed_str += cut_value
                pstr_len += len(cut_value)

                break # stop processing the input data
        else:
            raise NotImplementedError(part_value)

    if pstr_len > t_width:
        raise Exception(f'Assertion failed: "{printed_str}"')

    return printed_str

def _sanity_check_data_row(data_row, i):
    for part_idx, part_value in enumerate(data_row):
        part_str_id = f'Screen data row with index {i} part {part_idx}'

        if not isinstance(part_value, str) and not isinstance(part_value, TermCtrl):
            raise ValueError(f'{part_str_id} is not "str" nor "TermCtrl"')
        if isinstance(part_value, str):
            for c in ['\n', '\r', '\t']:
                if c in part_value:
                    raise ValueError(
                        f'{part_str_id} cannot contain the ASCII character {ord(c)}: "{part_value}"'
                    )

def ui_print(term, data):
    # get it every time, so that we react if the terminal changes (ie. if it gets resized)
    t_height = term.height
    t_width = term.width

    term_size_changed = False
    if 'ui_old_size' not in gvars \
      or t_height != gvars['ui_old_size']['height'] or t_width != gvars['ui_old_size']['width']:
        #
        term_size_changed = True
        gvars['ui_old_size'] = {
            'height': t_height,
            'width': t_width,
        }

    if term_size_changed:
        print(term.clear(), end='', flush=True)
        if 'ui_old_screen' in gvars:
            del gvars['ui_old_screen']

    if 'ui_old_screen' not in gvars:
        gvars['ui_old_screen'] = {}
    old_screen = gvars['ui_old_screen']

    screen_changed = False
    for i in range(0, t_height):
        if i not in old_screen: # first initialization of "old_screen"
            old_screen[i] = None

        try:
            data_row = data[i]
        except IndexError:
            data_row = ['']

        _sanity_check_data_row(data_row, i)

        printed_str = _compose_printed_str(data_row, t_width)

        if printed_str != old_screen[i]: # this could be optimized to draw only a part of the line
            old_screen[i] = printed_str
            screen_changed = True
            # always restore the color to "normal" in case we cut this in _compose_printed_str()
            # always clear the line until the end in case we're printing something shorter now
            print(term.move(i, 0) + printed_str + term.normal + term.clear_eol, end='', flush=False)

    if screen_changed:
        sys.stdout.flush()

    return term_size_changed, t_height, t_width

def _compose_host_data_str(host_data, t_width):
    s = ''
    with host_data['lock']:
        for v_idx in range(1, len(host_data['parsed']) + 1):
            added_value = '{:3d} '.format(host_data['parsed'][-v_idx])

            if len(s) + len(added_value) > t_width:
                break

            s += added_value
    return s

def _ui_render_all_hosts_data(screen_rows, all_hosts, min_idx, max_idx, sel_idx, max_host_id_len, t_width):
    for idx, host in enumerate(list(all_hosts.keys())):
        if idx < min_idx:
            continue
        if idx > max_idx:
            continue

        row = []
        if sel_idx == idx:
            row.append(TermCtrl('bold'))

        host_id_str = ('{:<' + str(max_host_id_len) + 's} ').format(
            host[0:max_host_id_len]
        )
        row.append(host_id_str)

        row.append(_compose_host_data_str(
            all_hosts[host], t_width - len(host_id_str)
        ))

        screen_rows.append(row)

def ui_renderer(all_hosts):
    term = gvars['term']

    if term.number_of_colors < 8:
        raise Exception('Your terminal does not support colors')

    with gvars['exit_fullscreen_lock']:
        gvars['exited_fullscreen'] = False
        print(term.enter_fullscreen())

    screen_rows = []
    cmd_err = ['']
    max_host_id_len = 16
    with term.hidden_cursor():
        while not gvars['stop_run']:
            term_size_changed, t_height, t_width = ui_print(term, screen_rows)

            if not term_size_changed:
                time.sleep(0.05)

            screen_rows = []

            screen_rows.append([
                'Keys: ',
                TermCtrl('bold'), '↑', TermCtrl('normal'),
                '/',
                TermCtrl('bold'), '↓', TermCtrl('normal'),
                '/',
                TermCtrl('bold'), 'Enter', TermCtrl('normal'),
                '/',
                TermCtrl('bold'), 'PgUp', TermCtrl('normal'),
                '/',
                TermCtrl('bold'), 'PgDn', TermCtrl('normal'),
                ' | ',
                TermCtrl('bold'), 'Q', TermCtrl('normal'), 'uit',
            ])
            screen_rows.append(cmd_err)
            screen_rows.append([
                TermCtrl('bold'),
                ('{:<' + str(max_host_id_len) + 's} ').format('Hostname'),
                'Ping results', TermCtrl('normal'), ' (newest first)',
            ])

            if term_size_changed:
                avail_term_rows = t_height - len(screen_rows) # skip the header rows
                hosts_count = len(all_hosts.keys())
                min_idx = 0
                max_idx = min(min_idx + avail_term_rows - 1, hosts_count - 1)
                sel_idx = None

            with gvars['keys_pressed_lock']:
                while len(gvars['keys_pressed_list']):
                    key = gvars['keys_pressed_list'].pop(0)
                    cmd_err = ['']

                    min_idx_updated = False
                    if key == '<DOWN>':
                        if sel_idx is not None:
                            sel_idx += 1
                        if sel_idx is None or sel_idx > max_idx:
                            sel_idx = min_idx
                    elif key == '<UP>':
                        if sel_idx is not None:
                            sel_idx -= 1
                        if sel_idx is None or sel_idx < min_idx:
                            sel_idx = max_idx
                    elif key == '<PAGEUP>':
                        if min_idx > 0:
                            min_idx -= 5
                            min_idx_updated = True
                    elif key == '<PAGEDOWN>':
                        if max_idx < hosts_count - 1:
                            min_idx += 5
                            min_idx_updated = True
                    elif key == '<ENTER>':
                        if sel_idx is None:
                            cmd_err = [
                                TermCtrl('bold'), TermCtrl('red'),
                                'You need to select a row with the up and down arrows first',
                            ]
                    elif key == '<ESC>':
                        pass
                    elif key.lower() == 'q':
                        gvars['stop_run'] = True
                    else:
                        cmd_err = [TermCtrl('bold'), TermCtrl('red'), f'Unknown command "{key}"']

                    if min_idx_updated:
                        max_idx = min(min_idx + avail_term_rows - 1, hosts_count - 1)
                        sel_idx = None

            if max_idx < 0:
                # terminal is so small that it doesn't have any space for data, or there
                # is no data
                continue

            _ui_render_all_hosts_data(
                screen_rows, all_hosts, min_idx, max_idx, sel_idx, max_host_id_len, t_width
            )

    # only this thread and Exceptions print any info
    # therefore, it's this thread's task to exit full screen
    exit_fullscreen()

def _exit_fullscreen():
    if not gvars['exited_fullscreen']:
        gvars['exited_fullscreen'] = True
        print(gvars['term'].exit_fullscreen(), end='', flush=True)

def exit_fullscreen():
    if threading.current_thread() != gvars['ui_renderer_thread']: # avoid deadlock
        with gvars['exit_fullscreen_lock']:
            _exit_fullscreen()
    else: # ui_renderer_thread (the only thread which can set "exited_fullscreen = False"
        _exit_fullscreen()

def thread_runner(*args):
    try:
        func = args[0]
        func(*args[1:])
    except:
        gvars['stop_run'] = True

        if threading.current_thread() != gvars['ui_renderer_thread']:
            # this thread must exit very soon, because of the gvars['stop_run'] == False
            # wait for it to call exit_fullscreen(), so that we can successfully
            # print() the exception info
            gvars['ui_renderer_thread'].join(5) # best effort

        exit_fullscreen()
        raise # and print() the exception info

def stdin_processor():
    with curtsies.Input() as input_generator:
        while not gvars['stop_run']:
            e = input_generator.send(0.05)
            if e is None:
                continue # nothing pressed within the timeout period

            with gvars['keys_pressed_lock']:
                key = str(e)
                if key == '<Ctrl-j>':
                    key = '<ENTER>'

                gvars['keys_pressed_list'].append(key)

def sigint_handler(a, b):
    gvars['stop_run'] = True

def get_hosts():
    ret = {}
    for i in range(1, 51):
        ret['host-{} {}'.format(i, str(i)*i)] = {
            'lock': threading.Lock(),
            'parsed': [],
            'raw': [],
        }
    return ret

def update_hosts_data():
    while not gvars['stop_run']:
        for hostname, data in gvars['proc_data'].items():
            if random.randint(0, 1):
                continue

            n = random.randint(0, 900)
            with data['lock']:
                data['parsed'].append(n)
                data['raw'].append(f'Ping reply {n} ms')

        time.sleep(0.1)

def main():
    gvars['term'] = Terminal()

    gvars['stop_run'] = False

    gvars['keys_pressed_list'] = []
    gvars['keys_pressed_lock'] = threading.Lock()

    gvars['exited_fullscreen'] = True # by default we're not in this mode
    gvars['exit_fullscreen_lock'] = threading.Lock()

    gvars['proc_data'] = get_hosts()

    gvars['ui_renderer_thread'] = threading.Thread(target=thread_runner, args=(
        ui_renderer, gvars['proc_data']
    ))

    thr_list = [
        gvars['ui_renderer_thread'],
        threading.Thread(target=thread_runner, args=(stdin_processor,)),
        threading.Thread(target=thread_runner, args=(update_hosts_data,)),
    ]

    signal.signal(signal.SIGINT, sigint_handler) # CTRL+C

    for thr in thr_list:
        thr.start()

    while not gvars['stop_run']:
        time.sleep(0.05)

    while threading.active_count() > 1:
        for thr in thr_list:
            if thr.is_alive():
                thr.join()
        time.sleep(0.05)

thread_runner(main)
